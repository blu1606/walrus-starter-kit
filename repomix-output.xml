This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: packages/cli/package.json, packages/cli/src/index.ts, packages/cli/src/post-install/**/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
packages/
  cli/
    src/
      post-install/
        git.ts
        index.ts
        messages.ts
        package-manager.ts
        post-install.test.ts
        validator.ts
      index.ts
    package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="packages/cli/src/post-install/git.ts">
import spawn from 'cross-spawn';
import fs from 'fs-extra';
import path from 'node:path';
import { logger } from '../utils/logger.js';

export interface GitResult {
  success: boolean;
  error?: Error;
}

/**
 * Check if git is available
 */
async function isGitAvailable(): Promise<boolean> {
  return new Promise((resolve) => {
    const child = spawn('git', ['--version'], { stdio: 'ignore' });
    child.on('close', (code: number | null) => resolve(code === 0));
    child.on('error', () => resolve(false));
  });
}

/**
 * Initialize git repository
 */
export async function initializeGit(projectPath: string): Promise<GitResult> {
  // Check if git is available
  if (!(await isGitAvailable())) {
    logger.warn('‚ö†Ô∏è  Git not found, skipping initialization');
    return { success: false };
  }

  // Check if already a git repo
  if (await fs.pathExists(path.join(projectPath, '.git'))) {
    logger.info('üìù Git repository already exists');
    return { success: true };
  }

  logger.info('üìù Initializing git repository...');

  // Run git init
  return new Promise((resolve) => {
    const child = spawn('git', ['init'], {
      cwd: projectPath,
      stdio: 'ignore',
    });

    child.on('close', (code: number | null) => {
      if (code === 0) {
        logger.success('‚úì Git repository initialized');
        resolve({ success: true });
      } else {
        resolve({
          success: false,
          error: new Error(`git init failed with code ${code}`),
        });
      }
    });

    child.on('error', (error: Error) => {
      resolve({ success: false, error });
    });
  });
}

/**
 * Create initial commit
 */
export async function createInitialCommit(
  projectPath: string
): Promise<GitResult> {
  if (!(await fs.pathExists(path.join(projectPath, '.git')))) {
    return { success: false, error: new Error('Not a git repository') };
  }

  logger.info('üìù Creating initial commit...');

  // Stage all files
  return new Promise((resolve) => {
    const addChild = spawn('git', ['add', '.'], {
      cwd: projectPath,
      stdio: 'ignore',
    });

    addChild.on('close', (code: number | null) => {
      if (code !== 0) {
        resolve({ success: false, error: new Error('git add failed') });
        return;
      }

      // Create commit
      const commitChild = spawn(
        'git',
        ['commit', '-m', 'chore: initial commit from create-walrus-app'],
        {
          cwd: projectPath,
          stdio: 'ignore',
        }
      );

      commitChild.on('close', (commitCode: number | null) => {
        if (commitCode === 0) {
          logger.success('‚úì Initial commit created');
          resolve({ success: true });
        } else {
          resolve({ success: false, error: new Error('git commit failed') });
        }
      });

      commitChild.on('error', (error: Error) => {
        resolve({ success: false, error });
      });
    });

    addChild.on('error', (error: Error) => {
      resolve({ success: false, error });
    });
  });
}
</file>

<file path="packages/cli/src/post-install/index.ts">
import { logger } from '../utils/logger.js';
import { installDependencies } from './package-manager.js';
import { initializeGit, createInitialCommit } from './git.js';
import { validateProject } from './validator.js';
import { displaySuccess, displayError } from './messages.js';
import type { Context } from '../types.js';

export interface PostInstallOptions {
  context: Context;
  projectPath: string;
  skipInstall?: boolean;
  skipGit?: boolean;
  skipValidation?: boolean;
}

export interface PostInstallResult {
  success: boolean;
  installed: boolean;
  gitInitialized: boolean;
  validated: boolean;
  error?: Error;
}

export async function runPostInstall(
  options: PostInstallOptions
): Promise<PostInstallResult> {
  const {
    context,
    projectPath,
    skipInstall = false,
    skipGit = false,
    skipValidation = false,
  } = options;

  const result: PostInstallResult = {
    success: true,
    installed: false,
    gitInitialized: false,
    validated: false,
  };

  try {
    // Step 1: Install dependencies
    if (!skipInstall) {
      const installResult = await installDependencies(
        projectPath,
        context.packageManager
      );
      result.installed = installResult.success;

      if (!installResult.success) {
        logger.warn(
          '‚ö†Ô∏è  Dependency installation failed, but project was created'
        );
        logger.info('üí° You can install manually by running:');
        logger.info(`   cd ${context.projectName}`);
        logger.info(`   ${context.packageManager} install`);
      }
    }

    // Step 2: Initialize git
    if (!skipGit) {
      const gitResult = await initializeGit(projectPath);
      result.gitInitialized = gitResult.success;

      if (gitResult.success) {
        const commitResult = await createInitialCommit(projectPath);
        if (!commitResult.success) {
          logger.warn('‚ö†Ô∏è  Initial commit failed, but git repo was created');
        }
      }
    }

    // Step 3: Validate project
    if (!skipValidation && result.installed) {
      const validationResult = await validateProject(projectPath);
      result.validated = validationResult.valid;

      if (!validationResult.valid) {
        logger.warn('‚ö†Ô∏è  Project validation failed:');
        validationResult.errors.forEach((err) => logger.warn(`   - ${err}`));
      }
    }

    // Display success message
    displaySuccess(context);

    return result;
  } catch (error) {
    result.success = false;
    result.error = error as Error;

    displayError(error as Error, context);

    return result;
  }
}
</file>

<file path="packages/cli/src/post-install/messages.ts">
import kleur from 'kleur';
import { logger } from '../utils/logger.js';
import { getRunCommand } from './package-manager.js';
import type { Context } from '../types.js';

/**
 * Display success message with next steps
 */
export function displaySuccess(context: Context): void {
  const { projectName, packageManager, sdk, framework, useCase } = context;

  console.log('\n' + kleur.green('‚îÅ'.repeat(60)));
  console.log(kleur.bold().green('  ‚ú® Project created successfully! ‚ú®'));
  console.log(kleur.green('‚îÅ'.repeat(60)));

  console.log('\n' + kleur.bold('üì¶ Project Details:'));
  console.log(`  Name: ${kleur.cyan(projectName)}`);
  console.log(`  SDK: ${kleur.cyan(sdk)}`);
  console.log(`  Framework: ${kleur.cyan(framework)}`);
  console.log(`  Use Case: ${kleur.cyan(useCase)}`);

  console.log('\n' + kleur.bold('üöÄ Next Steps:'));
  console.log(`  ${kleur.gray('1.')} cd ${kleur.cyan(projectName)}`);
  console.log(
    `  ${kleur.gray('2.')} ${kleur.cyan(getRunCommand(packageManager, 'dev'))}`
  );

  console.log('\n' + kleur.bold('üìö Helpful Commands:'));
  console.log(
    `  ${kleur.cyan(getRunCommand(packageManager, 'dev'))}      - Start development server`
  );
  console.log(
    `  ${kleur.cyan(getRunCommand(packageManager, 'build'))}    - Build for production`
  );
  console.log(
    `  ${kleur.cyan(getRunCommand(packageManager, 'lint'))}     - Run linter`
  );

  console.log('\n' + kleur.bold('üîó Resources:'));
  console.log(`  Walrus Docs:   ${kleur.cyan('https://docs.walrus.site')}`);
  console.log(`  Sui Docs:      ${kleur.cyan('https://docs.sui.io')}`);
  console.log(
    `  Sui Faucet:    ${kleur.cyan('https://faucet.testnet.sui.io')}`
  );

  console.log('\n' + kleur.bold('üí° Tips:'));
  console.log(
    `  - Copy ${kleur.cyan('.env.example')} to ${kleur.cyan('.env')}`
  );
  console.log(`  - Install Sui Wallet browser extension`);
  console.log(`  - Get testnet SUI from the faucet`);

  console.log('\n' + kleur.green('‚îÅ'.repeat(60)) + '\n');
}

/**
 * Display error message with recovery steps
 */
export function displayError(error: Error, context: Context): void {
  console.log('\n' + kleur.red('‚îÅ'.repeat(60)));
  console.log(kleur.bold().red('  ‚ùå Project creation failed'));
  console.log(kleur.red('‚îÅ'.repeat(60)));

  console.log('\n' + kleur.bold('Error:'));
  console.log(`  ${kleur.red(error.message)}`);

  console.log('\n' + kleur.bold('Recovery Steps:'));
  console.log(`  ${kleur.gray('1.')} cd ${kleur.cyan(context.projectName)}`);
  console.log(
    `  ${kleur.gray('2.')} ${kleur.cyan(`${context.packageManager} install`)}`
  );
  console.log(
    `  ${kleur.gray('3.')} Try running ${kleur.cyan(getRunCommand(context.packageManager, 'dev'))}`
  );

  console.log('\n' + kleur.bold('Need Help?'));
  console.log(
    `  Report issues: ${kleur.cyan('https://github.com/your-org/walrus-starter-kit/issues')}`
  );

  console.log('\n' + kleur.red('‚îÅ'.repeat(60)) + '\n');
}
</file>

<file path="packages/cli/src/post-install/package-manager.ts">
import spawn from 'cross-spawn';
import { logger } from '../utils/logger.js';
import type { PackageManager } from '../types.js';

export interface InstallResult {
  success: boolean;
  duration: number;
  error?: Error;
}

/**
 * Get install command for package manager
 */
function getInstallCommand(pm: PackageManager): string {
  const commands: Record<PackageManager, string> = {
    npm: 'npm install',
    pnpm: 'pnpm install',
    yarn: 'yarn',
    bun: 'bun install',
  };
  return commands[pm];
}

/**
 * Install dependencies using detected package manager
 */
export async function installDependencies(
  projectPath: string,
  packageManager: PackageManager
): Promise<InstallResult> {
  const startTime = Date.now();

  logger.info(`üì¶ Installing dependencies with ${packageManager}...`);

  return new Promise((resolve) => {
    const [cmd, ...args] = getInstallCommand(packageManager).split(' ');

    const child = spawn(cmd, args, {
      cwd: projectPath,
      stdio: 'inherit', // Stream output to user
    });

    child.on('close', (code: number | null) => {
      const duration = Date.now() - startTime;

      if (code === 0) {
        logger.success(
          `‚úì Dependencies installed (${(duration / 1000).toFixed(1)}s)`
        );
        resolve({ success: true, duration });
      } else {
        const error = new Error(`Install failed with exit code ${code}`);
        logger.error(`‚ùå Dependency installation failed`);
        resolve({ success: false, duration, error });
      }
    });

    child.on('error', (error: Error) => {
      const duration = Date.now() - startTime;
      logger.error(`‚ùå Failed to run ${packageManager}: ${error.message}`);
      resolve({ success: false, duration, error });
    });
  });
}

/**
 * Get run command for package manager
 */
export function getRunCommand(pm: PackageManager, script: string): string {
  const runCommands: Record<PackageManager, string> = {
    npm: `npm run ${script}`,
    pnpm: `pnpm ${script}`,
    yarn: `yarn ${script}`,
    bun: `bun run ${script}`,
  };
  return runCommands[pm];
}
</file>

<file path="packages/cli/src/post-install/post-install.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { installDependencies, getRunCommand } from './package-manager.js';
import { initializeGit, createInitialCommit } from './git.js';
import { validateProject } from './validator.js';
import { runPostInstall } from './index.js';
import spawn from 'cross-spawn';
import fs from 'fs-extra';
import { logger } from '../utils/logger.js';

vi.mock('cross-spawn');
vi.mock('fs-extra');
vi.mock('../utils/logger.js');

describe('Post-Install & Validation', () => {
  const projectPath = '/mock/project';
  const context = {
    projectName: 'test-app',
    projectPath,
    sdk: 'mysten' as const,
    framework: 'react' as const,
    useCase: 'simple-upload' as const,
    analytics: false,
    tailwind: true,
    packageManager: 'pnpm' as const,
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('Package Manager Logic', () => {
    it('should call pnpm install for pnpm', async () => {
      const mockSpawn = vi.mocked(spawn).mockReturnValue({
        on: vi.fn().mockImplementation((event, cb) => {
          if (event === 'close') cb(0);
          return { on: vi.fn() };
        }),
      } as any);

      await installDependencies(projectPath, 'pnpm');
      expect(mockSpawn).toHaveBeenCalledWith(
        'pnpm',
        ['install'],
        expect.any(Object)
      );
    });

    it('should call yarn for yarn', async () => {
      const mockSpawn = vi.mocked(spawn).mockReturnValue({
        on: vi.fn().mockImplementation((event, cb) => {
          if (event === 'close') cb(0);
          return { on: vi.fn() };
        }),
      } as any);

      await installDependencies(projectPath, 'yarn');
      expect(mockSpawn).toHaveBeenCalledWith('yarn', [], expect.any(Object));
    });

    it('should return correct run commands', () => {
      expect(getRunCommand('npm', 'dev')).toBe('npm run dev');
      expect(getRunCommand('pnpm', 'dev')).toBe('pnpm dev');
      expect(getRunCommand('yarn', 'dev')).toBe('yarn dev');
      expect(getRunCommand('bun', 'dev')).toBe('bun run dev');
    });
  });

  describe('Git Logic', () => {
    it('should initialize git if not already present', async () => {
      vi.mocked(fs.pathExists).mockImplementation(async () => false);
      const mockSpawn = vi.mocked(spawn).mockReturnValue({
        on: vi.fn().mockImplementation((event, cb) => {
          if (event === 'close') cb(0);
          return { on: vi.fn() };
        }),
      } as any);

      const result = await initializeGit(projectPath);
      expect(result.success).toBe(true);
      expect(mockSpawn).toHaveBeenCalledWith(
        'git',
        ['init'],
        expect.any(Object)
      );
    });

    it('should create initial commit', async () => {
      vi.mocked(fs.pathExists).mockImplementation(async () => true);
      const mockSpawn = vi.mocked(spawn).mockReturnValue({
        on: vi.fn().mockImplementation((event, cb) => {
          if (event === 'close') cb(0);
          return { on: vi.fn() };
        }),
      } as any);

      const result = await createInitialCommit(projectPath);
      expect(result.success).toBe(true);
      expect(mockSpawn).toHaveBeenCalledWith(
        'git',
        ['add', '.'],
        expect.any(Object)
      );
      expect(mockSpawn).toHaveBeenCalledWith(
        'git',
        ['commit', '-m', expect.any(String)],
        expect.any(Object)
      );
    });
  });

  describe('Project Validator', () => {
    it('should validate valid project', async () => {
      vi.mocked(fs.readJson).mockResolvedValue({
        name: 'test',
        version: '1.0.0',
      });
      vi.mocked(fs.pathExists).mockImplementation(async (p: string) => {
        if (p.includes('node_modules')) return true;
        if (p.includes('package.json')) return true;
        return false;
      });

      const result = await validateProject(projectPath);
      expect(result.valid).toBe(true);
      expect(result.checks.packageJson).toBe(true);
      expect(result.checks.nodeModules).toBe(true);
    });

    it('should fail if node_modules missing', async () => {
      vi.mocked(fs.readJson).mockResolvedValue({
        name: 'test',
        version: '1.0.0',
      });
      vi.mocked(fs.pathExists).mockImplementation(async (p: string) => {
        if (p.includes('node_modules')) return false;
        if (p.includes('package.json')) return true;
        return false;
      });

      const result = await validateProject(projectPath);
      expect(result.valid).toBe(false);
      expect(result.errors).toContain('node_modules not found');
    });
  });

  describe('runPostInstall Orchestration', () => {
    it('should run all steps by default', async () => {
      const mockSpawn = vi.mocked(spawn).mockReturnValue({
        on: vi.fn().mockImplementation((event, cb) => {
          if (event === 'close') cb(0);
          return { on: vi.fn() };
        }),
      } as any);

      vi.mocked(fs.pathExists).mockImplementation(async () => true);
      vi.mocked(fs.readJson).mockResolvedValue({
        name: 'test',
        version: '1.0.0',
      });

      const result = await runPostInstall({ context, projectPath });

      expect(result.success).toBe(true);
      expect(result.installed).toBe(true);
      expect(result.gitInitialized).toBe(true);
      expect(result.validated).toBe(true);
    });

    it('should skip install when skipInstall is true', async () => {
      const result = await runPostInstall({
        context,
        projectPath,
        skipInstall: true,
      });
      expect(result.installed).toBe(false);
      expect(result.validated).toBe(false);
    });

    it('should skip git when skipGit is true', async () => {
      const result = await runPostInstall({
        context,
        projectPath,
        skipGit: true,
      });
      expect(result.gitInitialized).toBe(false);
    });

    it('should skip validation when skipValidation is true', async () => {
      vi.mocked(spawn).mockReturnValue({
        on: vi.fn().mockImplementation((event, cb) => {
          if (event === 'close') cb(0);
          return { on: vi.fn() };
        }),
      } as any);

      const result = await runPostInstall({
        context,
        projectPath,
        skipValidation: true,
      });
      expect(result.validated).toBe(false);
    });
  });
});
</file>

<file path="packages/cli/src/post-install/validator.ts">
import fs from 'fs-extra';
import path from 'node:path';
import spawn from 'cross-spawn';
import { logger } from '../utils/logger.js';

export interface ValidationResult {
  valid: boolean;
  checks: {
    packageJson: boolean;
    nodeModules: boolean;
    dependencies: boolean;
    typescript: boolean;
  };
  errors: string[];
}

/**
 * Validate generated project
 */
export async function validateProject(
  projectPath: string
): Promise<ValidationResult> {
  logger.info('üîç Validating project...');

  const result: ValidationResult = {
    valid: true,
    checks: {
      packageJson: false,
      nodeModules: false,
      dependencies: false,
      typescript: false,
    },
    errors: [],
  };

  // Check 1: package.json exists and is valid
  try {
    const pkgPath = path.join(projectPath, 'package.json');
    const pkg = await fs.readJson(pkgPath);

    if (!pkg.name || !pkg.version) {
      result.errors.push('package.json missing required fields');
    } else {
      result.checks.packageJson = true;
    }
  } catch (error) {
    result.errors.push('Invalid or missing package.json');
  }

  // Check 2: node_modules exists
  const nodeModulesPath = path.join(projectPath, 'node_modules');
  if (await fs.pathExists(nodeModulesPath)) {
    result.checks.nodeModules = true;
  } else {
    result.errors.push('node_modules not found');
  }

  // Check 3: Dependencies installed
  try {
    const pkgPath = path.join(projectPath, 'package.json');
    const pkg = await fs.readJson(pkgPath);
    const deps = { ...pkg.dependencies, ...pkg.devDependencies };

    let allInstalled = true;
    for (const dep in deps) {
      const depPath = path.join(nodeModulesPath, dep);
      if (!(await fs.pathExists(depPath))) {
        allInstalled = false;
        result.errors.push(`Dependency not installed: ${dep}`);
        break;
      }
    }

    result.checks.dependencies = allInstalled;
  } catch (error) {
    result.errors.push('Failed to verify dependencies');
  }

  // Check 4: TypeScript compilation (if tsconfig exists)
  const tsconfigPath = path.join(projectPath, 'tsconfig.json');
  if (await fs.pathExists(tsconfigPath)) {
    const tscResult = await checkTypeScript(projectPath);
    result.checks.typescript = tscResult.success;

    if (!tscResult.success) {
      result.errors.push(`TypeScript errors: ${tscResult.error}`);
    }
  } else {
    result.checks.typescript = true; // Not applicable
  }

  result.valid = Object.values(result.checks).every(Boolean);

  if (result.valid) {
    logger.success('‚úì Project validation passed');
  } else {
    logger.warn('‚ö†Ô∏è  Project validation failed:');
    result.errors.forEach((err) => logger.warn(`  - ${err}`));
  }

  return result;
}

/**
 * Check TypeScript compilation with timeout
 */
async function checkTypeScript(
  projectPath: string
): Promise<{ success: boolean; error?: string }> {
  return new Promise((resolve) => {
    const child = spawn('npx', ['tsc', '--noEmit'], {
      cwd: projectPath,
      stdio: 'pipe',
    });

    const timeout = setTimeout(() => {
      child.kill();
      resolve({ success: false, error: 'TypeScript check timed out (60s)' });
    }, 60000); // 60s timeout

    let stderr = '';
    child.stderr?.on('data', (data: Buffer) => {
      stderr += data.toString();
    });

    child.on('close', (code: number | null) => {
      clearTimeout(timeout);
      if (code === 0) {
        resolve({ success: true });
      } else {
        resolve({ success: false, error: stderr.split('\n')[0] });
      }
    });

    child.on('error', (error: Error) => {
      clearTimeout(timeout);
      resolve({ success: false, error: error.message });
    });
  });
}
</file>

<file path="packages/cli/src/index.ts">
#!/usr/bin/env node

import { program } from 'commander';
import { runPrompts } from './prompts.js';
import { buildContext } from './context.js';
import { validateContext } from './validator.js';
import { logger } from './utils/logger.js';
import { generateProject } from './generator/index.js';
import { runPostInstall } from './post-install/index.js';
import { readFileSync } from 'node:fs';
import { fileURLToPath } from 'node:url';
import { dirname, join } from 'node:path';
import fs from 'fs-extra';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const packageJson = JSON.parse(
  readFileSync(join(__dirname, '../package.json'), 'utf-8')
);

// Track current generation path for cleanup on interrupt
let currentGenerationPath: string | null = null;

program
  .name('create-walrus-app')
  .description('Interactive CLI for scaffolding Walrus applications')
  .version(packageJson.version)
  .argument('[project-name]', 'Project directory name')
  .option('--sdk <sdk>', 'SDK to use (mysten | tusky | hibernuts)')
  .option('--framework <framework>', 'Framework (react | vue | plain-ts)')
  .option(
    '--use-case <use-case>',
    'Use case (simple-upload | gallery | defi-nft)'
  )
  .option('--analytics', 'Include Blockberry analytics', false)
  .option('--no-tailwind', 'Exclude Tailwind CSS')
  .option('--skip-install', 'Skip dependency installation', false)
  .option('--skip-git', 'Skip git initialization', false)
  .option('--skip-validation', 'Skip project validation', false)
  .action(async (projectNameArg, options) => {
    try {
      logger.info('üöÄ Welcome to Walrus Starter Kit!');

      // Build initial context from args
      const initialContext = {
        projectName: projectNameArg,
        ...options,
      };

      // Run interactive prompts (skips questions with provided args)
      const promptResults = await runPrompts(initialContext);

      // Build final context
      const context = buildContext(options, promptResults);

      // Validate compatibility
      const validation = validateContext(context);
      if (!validation.valid) {
        logger.error(validation.error!);
        if (validation.suggestion) {
          logger.info(`üí° ${validation.suggestion}`);
        }
        process.exit(1);
      }

      logger.success('‚úì Configuration valid!');
      console.log('\nContext:', context);

      // Track generation path for cleanup on interrupt
      currentGenerationPath = context.projectPath;

      // Generate project
      logger.info('\nüèóÔ∏è  Generating your Walrus application...\n');

      const result = await generateProject({
        context,
        templateDir: join(__dirname, '../templates'),
        targetDir: context.projectPath,
      });

      // Clear tracking after completion
      currentGenerationPath = null;

      if (!result.success) {
        logger.error('‚ùå Project generation failed');
        process.exit(1);
      }

      // Post-install tasks
      const postInstallResult = await runPostInstall({
        context,
        projectPath: context.projectPath,
        skipInstall: options.skipInstall,
        skipGit: options.skipGit,
        skipValidation: options.skipValidation,
      });

      if (!postInstallResult.success) {
        logger.warn('‚ö†Ô∏è  Post-install tasks completed with warnings');
      }
    } catch (error) {
      // Sanitize error messages - don't expose stack traces to users
      const message =
        error instanceof Error ? error.message : 'Unknown error occurred';
      logger.error(`Failed to create project: ${message}`);
      process.exit(1);
    }
  });

// Handle cleanup on abort
process.on('SIGINT', async () => {
  logger.warn('\n\nOperation cancelled by user.');

  // Clean up partial generation if in progress
  if (currentGenerationPath) {
    logger.info(`üßπ Cleaning up partial generation: ${currentGenerationPath}`);
    try {
      await fs.remove(currentGenerationPath);
      logger.success('‚úì Cleanup completed');
    } catch (error) {
      logger.error(`Failed to cleanup: ${error}`);
      logger.warn(`‚ö†Ô∏è  Please manually delete: ${currentGenerationPath}`);
    }
  }

  process.exit(0);
});

program.parse();
</file>

<file path="packages/cli/package.json">
{
  "name": "create-walrus-app",
  "version": "0.1.0",
  "description": "Interactive CLI for scaffolding Walrus applications",
  "type": "module",
  "bin": {
    "create-walrus-app": "./dist/index.js"
  },
  "files": [
    "dist",
    "templates"
  ],
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage",
    "test:integration": "node tests/integration/integration.test.mjs",
    "test:validation": "node tests/integration/validation.test.mjs",
    "test:manual": "node tests/integration/manual.test.js",
    "test:e2e": "vitest run tests/e2e",
    "test:all": "vitest run && pnpm test:e2e",
    "prepublishOnly": "pnpm build"
  },
  "keywords": [
    "walrus",
    "sui",
    "scaffold",
    "cli",
    "template"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "commander": "^11.1.0",
    "cross-spawn": "^7.0.3",
    "fs-extra": "^11.2.0",
    "kleur": "^4.1.5",
    "prompts": "^2.4.2",
    "sort-package-json": "^2.10.1"
  },
  "devDependencies": {
    "@types/cross-spawn": "^6.0.6",
    "@types/fs-extra": "^11.0.4",
    "@types/node": "^20.11.0",
    "@types/prompts": "^2.4.9",
    "@vitest/coverage-v8": "^4.0.17",
    "@vitest/ui": "^4.0.17",
    "execa": "^9.5.2",
    "strip-ansi": "^7.1.0",
    "typescript": "^5.3.0",
    "vitest": "^4.0.17"
  }
}
</file>

</files>
